var Schema = require('../lib/schema')var type = require('type-component')var mpath = require('mpath')var ValidationError = require('../errors/validation.js')exports = module.exports = Schema.extend(Document)function Document(options, key, parent) {  if (!(this instanceof Document)) return new Document(options, key, parent)  var schema  if (options && options.hasOwnProperty('schema')) {    schema = options.schema    options.schema = undefined  }  Schema.call(this, options, key, parent)  this.tree = {}  this.options.schema = this.tree  this.add(schema)}Document.cast(function (object, parent, target) {  if (object === undefined || object === null) return object;  var target = target || {}    , errors = new ValidationError(this)    , has_errors = false    , schema = this.options.schema  map(object, target, function(key, value) {    try {     return schema[key] ? schema[key].cast(value, target) : value    } catch (err) {      errors.add(key, err)      has_errors = true    }  })  if (has_errors) throw errors  else return target})Document.rule('schema', function(value, schema, next) {  var errors = new ValidationError(this)    , has_errors = false    , pending = 0    , schema = this.options.schema  map(value, undefined, function(key, value) {    pending += 1    if (schema[key]) schema[key].validate(value, function(err) {      if (err) {         errors.add(key, err)        has_errors = true      }      if (--pending === 0) next(errors)    })  })  if (has_errors) throw errors})Document.prototype.add = function(obj, prefix) {  prefix = prefix || ''  Object.keys(obj)  .forEach(function(key) {    if (!obj[key]) {      throw new TypeError('Invalid for schema at path `' + prefix + key + '`')    }    this.attr(prefix + key, obj[key])  }, this)}Document.prototype.attr = function(path, obj) {  if (obj === undefined)    return mpath.get(path, this, 'tree')  else mpath.set(path, this.type.infer(obj, path.split('.').pop(), this), this, 'tree')  return this}function map(object, target, fn) {  if (type(object) !== 'object') throw new TypeError('must be an object')  var seen = []    , cache = []  Object.keys(object)  .forEach(function(key) {    var index = seen.indexOf(object[key])      , value = index > -1           ? cache[index]           : (cache[seen.push(object[key])] = fn(key, object[key]))     if (target) target[key] = value  })}function cast(type, value, parent) {  if (type) return type.cast(value, parent)  else return value}